<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>4. 语句 - Gnu C Reference Manual</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "4. \u8bed\u53e5";
    var mkdocs_page_input_path = "Statement.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Gnu C Reference Manual</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../Preface/">前言</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Lexical-Elements/">1. 词法元素</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Data-Types/">2. 数据类型</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Expressions-And-Operators/">3. 表达式与操作符</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">4. 语句</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#Labels">4.1 标签</a></li>
    

    <li class="toctree-l2"><a href="#Expression-Statements">4.2 表达式语句</a></li>
    

    <li class="toctree-l2"><a href="#The-if-Statement">4.3 if 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-switch-Statement">4.4 switch 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-while-Statement">4.5 while 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-do-Statement">4.6 do 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-for-Statement">4.7 for 语句</a></li>
    

    <li class="toctree-l2"><a href="#Blocks">4.8 代码块</a></li>
    

    <li class="toctree-l2"><a href="#The-Null-Statement">4.9 空语句</a></li>
    

    <li class="toctree-l2"><a href="#The-goto-Statement">4.10 goto 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-break-Statement">4.11 break 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-continue-Statement">4.12 continue 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-return-Statement">4.13 return 语句</a></li>
    

    <li class="toctree-l2"><a href="#The-typedef-Statement">4.14 typedef 语句</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Function/">5. 函数</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Program-Structure-And-Scope/">6. 程序结构和作用域</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../A-Sample-Program/">7. 示例程序</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Appendix-A-Overflow/">附录A：溢出</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../License/">License</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Gnu C Reference Manual</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>4. 语句</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>语句用来执行动作以及控制程序流。你也可以写不做任何事情的语句，或做一些丝毫没有用的事情。</p>
<h3 id="Labels">4.1 标签<a class="headerlink" href="#Labels" title="Permanent link">&para;</a></h3>
<p>你可以使用标签来标识源代码的一节，然后可以在后面的 <code>goto</code> 中使用（详见 <a href="#The-goto-Statement">goto 语句</a>）。一个标签包含一个标识符（就像之前用于变量名的一样）后跟一个冒号。如：</p>
<pre><code>treet:
</code></pre>

<p>但你要明白标签名字和其他标识符名字是不冲突的：</p>
<pre><code>int treet = 5;    /* treet the variable. */
treet:            /* treet the label. */
</code></pre>

<p>ISO C 标准要求标签后面必须至少跟一个语句，即便是一个空语句（详见 <a href="#The-Null-Statement">空语句</a>）。GCC 并不要求，但是要注意，如果你经常这样用，你的代码会有兼容性问题。</p>
<h3 id="Expression-Statements">4.2 表达式语句<a class="headerlink" href="#Expression-Statements" title="Permanent link">&para;</a></h3>
<p>你可以在任何表达式后面加上分号，来把它变成一个语句。例如：</p>
<pre><code>5;
2 + 2;
10 &gt;= 9;
</code></pre>

<p>在上面的各个语句中，表达式都会被求值。然而这并没什么卵用，因为他们既没有把值存起来，也没有做任何实际的事情，仅仅是计算了它们本身而已。编译器会忽略掉这种语句。</p>
<p>表达式语句仅在有副作用时有用，如存储一个值、函数调用或造成一个错误（这可能有点难懂）。例如：</p>
<pre><code>x++;
y = x + 25;
puts (&quot;Hello, user!&quot;);
*cucumber;
</code></pre>

<p>最后的语句 <code>*cucumber;</code> 可能会造成一个错误，如果 <code>cucumber</code> 的值不是一个合法的指针或者被声明为了 <code>volatile</code>。</p>
<h3 id="The-if-Statement">4.3 if 语句<a class="headerlink" href="#The-if-Statement" title="Permanent link">&para;</a></h3>
<p>你可以使用 <code>if</code> 语句来有条件地执行你的部分程序，执行部分取决于你给出的表达式的真值。常用形式如下：</p>
<pre><code>if (test)
    then-statement
else
    else-statement
</code></pre>

<p>如果 <em>test</em> 求值为真，那么执行 <em>then-statement</em> 语句而 <em>else-statement</em> 不会被执行。相反如果 <em>test</em> 为假，则 <em>else-statement</em> 被执行而 <em>then-statement</em> 不会被执行。<code>else</code> 从句是可选的。例如：</p>
<pre><code>if (x == 10)
    puts (&quot;x is 10&quot;);
</code></pre>

<p>如果 <code>x == 10</code> 是真，语句 <code>puts ("x is 10");</code> 被执行。如果 <code>x == 10</code> 是假，语句 <code>puts ("x is 10");</code> 不会被执行。</p>
<p>下面是使用 <code>else</code> 的例子：</p>
<pre><code>if (x == 10)
    puts (&quot;x is 10&quot;);
else
    puts (&quot;x is not 10&quot;);
</code></pre>

<p>你也可以使用一系列 <code>if</code> 语句来测试多个条件：</p>
<pre><code>if (x == 1)
    puts (&quot;x is 1&quot;);
else if (x == 2)
    puts (&quot;x is 2&quot;);
else if (x == 3)
    puts (&quot;x is 3&quot;);
else
    puts (&quot;x is something else&quot;);
</code></pre>

<p>下面的代码根据给定的年 <code>y</code> 来计算和打印复活节的日期：</p>
<pre><code>void
easterDate (int y)
{
    int n = 0;
    int g = (y % 19) + 1;
    int c = (y / 100) + 1;
    int x = ((3 * c) / 4) - 12;
    int z = (((8 * c) + 5) / 25) - 5;
    int d = ((5 * y) / 4) - x - 10;
    int e = ((11 * g) + 20 + z - x) % 30;

    if (((e == 25) &amp;&amp; (g &gt; 11)) || (e == 24))
        e++;

    n = 44 - e;

    if (n &lt; 21)
        n += 30;

    n = n + 7 - ((d + n) % 7);

    if (n &gt; 31)
        printf (&quot;Easter: %d April %d&quot;, n - 31, y);
    else
        printf (&quot;Easter: %d March %d&quot;, n, y);
}
</code></pre>

<h3 id="The-switch-Statement">4.4 switch 语句<a class="headerlink" href="#The-switch-Statement" title="Permanent link">&para;</a></h3>
<p>你可以使用 <code>switch</code> 语句来把一个表达式和其他表达式作比较，然后根据比较结果决定是否执行一系列子语句。下面是 <code>switch</code> 的一般形式：</p>
<pre><code>switch (test)
{
case compare-1:
    if-equal-statement-1
case compare-2:
    if-equal-statement-2
…
default:
    default-statement
}
</code></pre>

<p><code>switch</code> 语句比较 <em>test</em> 和每一个 <em>compare</em> 表达式，直到找到一个和 <em>test</em> 相等的。然后该分支下面的语句会被执行。所有被比较的表达式必须是整数类型，并且 <em>compare-N</em> 必须是一个常量整型（例如，一个字面量整数或一个字面量整数组成的表达式）。</p>
<p>可选地，你可以指定一个 默认（default） 分支。如果上面的分支都没有匹配到就会执行该默认分支。一般 default 都会放在最后，但这不是强制的。</p>
<pre><code>switch (x)
{
case 0:
    puts (&quot;x is 0&quot;);
    break;
case 1:
    puts (&quot;x is 1&quot;);
    break;
default:
    puts (&quot;x is something else&quot;);
    break;
}
</code></pre>

<p>注意到，上面每个分支都用了一个 <code>break</code> 语句。这是因为，如果一个分支被匹配到，不只是它的子句被执行，所有它下面的分支的子句也会执行：</p>
<pre><code>int x = 0;
switch (x)
{
case 0:
    puts (&quot;x is 0&quot;);
case 1:
    puts (&quot;x is 1&quot;);
default:
    puts (&quot;x is something else&quot;);
}
</code></pre>

<p>这个例子的输出是：</p>
<pre><code>x is 0
x is 1
x is something else
</code></pre>

<p>这通常不是我们想要的。在每一个分支后面加一个 <code>break</code> 会将程序的执行流程引导到 <code>switch</code> 语句之后。</p>
<p>作为 GNU C 扩展，你可以在一个 <code>case</code> 标签里指定一个连续的整数值范围，如：</p>
<pre><code>case low ... high:
</code></pre>

<p>这个把该范围对应的各个数字 -- 包含 <em>low</em> 和 <em>high</em> -- 写在各自标签里的效果是一样的。</p>
<p>这个特性对于一个范围的 ASCII 字符尤其有用：</p>
<pre><code>case 'A' ... 'Z':
</code></pre>

<p>要注意，在 ... 两边都有空格；否则会解析出错。例如，可以这样写：</p>
<pre><code>case 1 ... 5:
</code></pre>

<p>而不是</p>
<pre><code>case 1...5:
</code></pre>

<p>通常使用 <code>switch</code> 语句来处理多种可能的 <code>errno</code>。这种情况下，一个可移植的程序应该注意到有可能 2 个使用 <code>errno</code> 的宏实际却有相同的值，例如 <code>EWOULDBLOCK</code> 和 <code>EAGAIN</code>。</p>
<h3 id="The-while-Statement">4.5 while 语句<a class="headerlink" href="#The-while-Statement" title="Permanent link">&para;</a></h3>
<p><code>while</code> 语句是一种在循环开始前进行退出测试的循环语句。下面是其一般形式：</p>
<pre><code>while (test)
    statement
</code></pre>

<p><code>while</code> 语句先对 <em>test</em> 求值。如果 <em>test</em> 是真，则 s<em>tatement</em> 被执行，然后再次对 <em>test</em> 求值。只要 <em>test</em> 为真，<em>statement</em> 会继续重复执行。</p>
<p>下面的例子打印整数 0 到 9：</p>
<pre><code>int counter = 0;
while (counter &lt; 10)
    printf (&quot;%d &quot;, counter++);
</code></pre>

<p><code>break</code> 语句可以终止 <code>while</code> 循环。</p>
<h3 id="The-do-Statement">4.6 do 语句<a class="headerlink" href="#The-do-Statement" title="Permanent link">&para;</a></h3>
<p><code>do</code> 语句是在循环末尾进行退出测试的循环语句。下面是其一般形式：</p>
<pre><code>do
    statement
while (test);
</code></pre>

<p><code>do</code> 语句先执行 <em>statement</em>。之后对 <em>test</em> 求值。如果 <em>test</em> 为真，<em>statement</em> 再次被执行。只要 <em>test</em> 为真，<em>statement</em> 会继续重复执行。</p>
<p>下面的例子打印整数 0 到 9：</p>
<pre><code>int x = 0;
do
    printf (&quot;%d &quot;, x++);
while (x &lt; 10);
</code></pre>

<p><code>break</code> 语句可以终止 <code>do</code> 循环。</p>
<h3 id="The-for-Statement">4.7 for 语句<a class="headerlink" href="#The-for-Statement" title="Permanent link">&para;</a></h3>
<p><code>for</code> 是一种循环语句，它的结构可以简单地变量初始化，表达式测试以及变量修改。方便于进行计数控制的循环。它的一般形式如下：</p>
<pre><code>for (initialize; test; step)
    statement
</code></pre>

<p><code>for</code> 循环先计算表达式 <em>initialize</em>，然后对表达式 <em>test</em> 求值。如果 <em>test</em> 为假，循环结束并且程序的控制流程恢复到 <code>for</code> 语句之后；否则，<em>statement</em> 被执行。最后，计算 <em>step</em>。下一次循环迭代会先再次对 <em>test</em> 求值。</p>
<p>通常，<em>initialize</em> 会给一个或多个变量赋值，一般是计数器； <em>test</em> 会把这些变量和预定义的表达式比较；而 <em>step</em> 用来修改这些变量。下面也是一个打印整数 0 ~ 9 的例子：</p>
<pre><code>int x;
for (x = 0; x &lt; 10; x++)
    printf (&quot;%d &quot;, x);
</code></pre>

<p>首先对 <em>initialize</em> 求值，也就是把 0 赋给 <code>x</code>。然后只要 <code>x</code> 小于 10 就会把它打印出来（在循环体中）。接着 <code>x</code> 在 <em>step</em> 子句里被递增，然后 <em>test</em> 再被求值。</p>
<p>这 3 个表达式在 <code>for</code> 语句中都是可选的，其中可以任意组合。既然第一个表达式只被求值一次，所以经常会被省略。上面的例子可以这样写：</p>
<pre><code>int x = 1;
for (; x &lt;= 10; x++)
    printf (&quot;%d &quot;, x);
</code></pre>

<p>在这个例子中，<code>x</code> 在 <code>for</code> 语句之前就被赋值了。</p>
<p>如果你不写 <em>test</em> 表达式，那 <code>for</code> 语句就变成无限循环了（除非你在 <code>for</code> 语句中使用了 <code>break</code> 或者 <code>goto</code> 语句）。这和 <em>test</em> 为 1 是一样的，永远为真。</p>
<p>下面的例子从 1 开始打印所有的正整数：</p>
<pre><code>for (x = 1; ; x++)
    printf (&quot;%d &quot;, x);
</code></pre>

<p>如果你不写 <em>step</em> 表达式，就没有了完成循环的步进 -- 至少不像 <code>for</code> 语句正常期望的那样。</p>
<p>下面的例子会不停地打印 1：</p>
<pre><code>for (x = 1; x &lt;= 10;)
    printf (&quot;%d &quot;, x);
</code></pre>

<p>可能会引起困惑的是，你不能使用逗号运算符（详见 <a href="../Expressions-And-Operators/#The-Comma-Operator">逗号操作符</a>）在同一个 <code>for</code> 语句中监控多个变量，因为通常逗号运算符会丢弃它的左操作数的结果。如：</p>
<pre><code>int x, y;
for (x = 1, y = 10; x &lt;= 10, y &gt;= 1; x+=2, y--)
    printf (&quot;%d %d\n&quot;, x, y);
</code></pre>

<p>输出是：</p>
<pre><code>1 10
3 9
5 8
7 7
9 6
11 5
13 4
15 3
17 2
19 1
</code></pre>

<p>如果你要测试 2 个条件，你需要用 <code>&amp;&amp;</code> 运算符：</p>
<pre><code>int x, y;
for (x = 1, y = 10; x &lt;= 10 &amp;&amp; y &gt;= 1; x+=2, y--)
    printf (&quot;%d %d\n&quot;, x, y);
</code></pre>

<p><code>break</code> 语句也可以终止 <code>for</code> 循环：</p>
<p>下面的例子是一个计算平方和的函数，给定一个起始数，一个终止数，来计算中间所有数的平方和：</p>
<pre><code>int
sum_of_squares (int start, int end)
{
    int i, sum = 0;
    for (i = start; i &lt;= end; i++)
    sum += i * i;
    return sum;
}
</code></pre>

<h3 id="Blocks">4.8 代码块<a class="headerlink" href="#Blocks" title="Permanent link">&para;</a></h3>
<p>一个代码块是 0 个或多个用花括号包起来的语句，也叫做组合语句。通常代码块用在条件语句和循环语句的主体部分，用来将一组语句放在一起。</p>
<pre><code>for (x = 1; x &lt;= 10; x++)
{
    printf (&quot;x is %d\n&quot;, x);

    if ((x % 2) == 0)
        printf (&quot;%d is even\n&quot;, x);
    else
        printf (&quot;%d is odd\n&quot;, x);
}
</code></pre>

<p>代码块可以嵌套：</p>
<pre><code>for (x = 1; x &lt;= 10; x++)
{
    if ((x % 2) == 0)
    {
        printf (&quot;x is %d\n&quot;, x);
        printf (&quot;%d is even\n&quot;, x);
    }
    else
    {
        printf (&quot;x is %d\n&quot;, x);
        printf (&quot;%d is odd\n&quot;, x);
    }
}
</code></pre>

<p>你可以在代码块内声明变量；这样的变量是该块的局部变量。在 C89 标准中，声明语句必须放在其他语句前，所以有时引入语句块来定义变量就很有用：</p>
<pre><code>{
    int x = 5;
    printf (&quot;%d\n&quot;, x);
}
printf (&quot;%d\n&quot;, x);   /* Compilation error! x exists only
                       in the preceding block. */
</code></pre>

<h3 id="The-Null-Statement">4.9 空语句<a class="headerlink" href="#The-Null-Statement" title="Permanent link">&para;</a></h3>
<p>空语句只有一个分号。</p>
<pre><code>;
</code></pre>

<p>空语句不做任何事情。不在任何地方存值。程序执行时不会耗时。</p>
<p>通常，空语句会用做循环语句的循环体，或者作为 <code>for</code> 语句中的一个或多个表达式。下面是一个空语句作为 <code>for</code> 循环的循环体的例子（顺便计算一下 n 的整数平方根，供君一笑）：</p>
<pre><code>for (i = 1; i*i &lt; n; i++)
    ;
</code></pre>

<p>下面是另一个用作 <code>for</code> 循环体的例子，但是会产生输出：</p>
<pre><code>for (x = 1; x &lt;= 5; printf (&quot;x is now %d\n&quot;, x), x++)
    ;
</code></pre>

<p>空语句有时也会跟在一个标签后面，用作该语句块的最后一个语句。</p>
<h3 id="The-goto-Statement">4.10 goto 语句<a class="headerlink" href="#The-goto-Statement" title="Permanent link">&para;</a></h3>
<p>你可以使用 <code>goto</code> 语句在程序中无条件跳转。形式一般为：</p>
<pre><code>goto label;
</code></pre>

<p>你必须指定目的标签；在 <code>goto</code> 语句执行时，程序就跳到了该标签处。详见 <a href="#Labels">标签</a> 一节。这里有个例子：</p>
<pre><code>goto end_of_program;
…
end_of_program:
</code></pre>

<p>标签可以在同一函数的任何地方，但 <code>goto</code> 跳不到其它函数。</p>
<p>你<em>可以</em>用 <code>goto</code> 来模拟循环，但我们不推荐这样做 -- 它让程序难以理解，并且 GCC 无法很好地优化它。你应该尽可能使用 <code>for</code>、<code>while</code> 以及 <code>do</code>
语句来实现循环。</p>
<p>GCC 扩展允许 <code>goto</code> 语句跳到 <code>void*</code> 指向的地址。要这样做，你还需要使用一元运算符 <code>&amp;&amp;</code>（不是 <code>&amp;</code>）拿到标签的地址。下面是一个瞎造的例子：</p>
<pre><code>enum Play { ROCK=0, PAPER=1, SCISSORS=2 };
enum Result { WIN, LOSE, DRAW };

static enum Result turn (void) 
{
  const void * const jumptable[] = {&amp;&amp;rock, &amp;&amp;paper, &amp;&amp;scissors};
  enum Play opp;                /* opponent’s play */
  goto *jumptable[select_option (&amp;opp)];
 rock:
  return opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);
 paper:
  return opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);
 scissors:
  return opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);
}
</code></pre>

<h3 id="The-break-Statement">4.11 break 语句<a class="headerlink" href="#The-break-Statement" title="Permanent link">&para;</a></h3>
<p>你可以使用 <code>break</code> 语句来终止 <code>while</code>、<code>do</code>、<code>for</code> 和 <code>switch</code> 语句。例如：</p>
<pre><code>int x;
for (x = 1; x &lt;= 10; x++)
{
    if (x == 8)
        break;
    else
        printf (&quot;%d &quot;, x);
}
</code></pre>

<p>这个例子会打印 1 到 7。当 <code>x</code> 自增到 8 时， <code>x == 8</code> 为真，因此 <code>break</code> 语句被执行，<code>for</code> 循环也就被终止了。</p>
<p>如果你把 <code>break</code> 放在了嵌套循环或 <code>switch</code> 的内层循环或内层 <code>switch</code> 中，那 <code>break</code> 只会终止最内层的循环或 <code>switch</code>。</p>
<h3 id="The-continue-Statement">4.12 continue 语句<a class="headerlink" href="#The-continue-Statement" title="Permanent link">&para;</a></h3>
<p>你可以在循环中使用 <code>continue</code> 语句来终止循环的当前一次迭代，然后开始下一次迭代。例如：</p>
<pre><code>for (x = 0; x &lt; 100; x++)
{
    if (x % 2 == 0)
        continue;
    else
        sum_of_odd_numbers + = x;
}
</code></pre>

<p>如果你把 <code>continue</code> 放在了嵌套循环的内层循环中，那 <code>continue</code> 只会终止最内层的循环。</p>
<h3 id="The-return-Statement">4.13 return 语句<a class="headerlink" href="#The-return-Statement" title="Permanent link">&para;</a></h3>
<p>你可以使用 <code>return</code> 语句来结束一个函数的执行，并将程序的控制交还到该函数的调用处。下面是 <code>return</code> 语句的一般形式：</p>
<pre><code>return return-value;
</code></pre>

<p><em>return-value</em> 是可选的。如果函数的返回值类型是 <code>void</code>，那返回一个表达式就是非法的；然而，你可以使用不带返回值的 <code>return</code> 语句。</p>
<p>如果函数的返回值类型和 <em>return-value</em> 的类型不一致，并且无法进行自动类型转换，那返回该 <em>return-value</em> 是非法的。</p>
<p>如果函数的返回值类型不是 <code>void</code>，并且没有返回值被指定，那该 <code>return</code> 语句是合法的，除非在函数被调用的上下文需要一个返回值：</p>
<pre><code>x = cosine (y);
</code></pre>

<p>在这个例子中，函数 <code>cosine</code> 被调用处需要一个返回值赋给 <code>x</code>。</p>
<p>即使上下文不需要一个返回值，缺省返回值为非 <code>void</code> 的函数的返回值不是个好习惯。GCC 中，你可以使用命令行参数 <code>-Wreturn-type</code>，在这样的函数中缺省返回值会发出警告。</p>
<p>下面的例子在 <code>void</code> 和非 <code>void</code> 函数中使用 <code>return</code> 语句：</p>
<pre><code>void
print_plus_five (int x)
{
    printf (&quot;%d &quot;, x + 5);
    return;
}
int
square_value (int x)
{
    return x * x;
}
</code></pre>

<h3 id="The-typedef-Statement">4.14 typedef 语句<a class="headerlink" href="#The-typedef-Statement" title="Permanent link">&para;</a></h3>
<p>你可以使用 <code>typedef</code> 语句来给数据类型创建别名。下面是其一般形式：</p>
<pre><code>typedef old-type-name new-type-name
</code></pre>

<p><em>old-type-name</em> 是该类型已经存在的名字，可能由不只一个标记组成（如 <code>unsigned long int</code>）。<em>new-type-name</em> 是该类型的新名字，并且必须是一个标识符。创建新名字后旧名字同样可用。例如：</p>
<pre><code>typedef unsigned char byte_type;
typedef double real_number_type;
</code></pre>

<p>对于自定义数据类型，你可以在定义该类型时就给它起一个新名字：</p>
<pre><code>typedef struct fish
{
    float weight;
    float length;
    float probability_of_being_caught;
} fish_type;
</code></pre>

<p>要给一个数组定义类型，你得先给出其元素的类型，然后是新的类型名，末尾接上元素个数：</p>
<pre><code>typedef char array_of_bytes [5];
array_of_bytes five_bytes = {0, 1, 2, 3, 4};
</code></pre>

<p>在选择类型的名字时，你要避免使用 <code>_t</code> 后缀。虽然编译器允许这么做，但 POSIX 标准将其保留作为标准库里的类型名字。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Function/" class="btn btn-neutral float-right" title="5. 函数">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../Expressions-And-Operators/" class="btn btn-neutral" title="3. 表达式与操作符"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../Expressions-And-Operators/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../Function/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
