<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>附录A：溢出 - Gnu C Reference Manual</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u9644\u5f55A\uff1a\u6ea2\u51fa";
    var mkdocs_page_input_path = "Appendix-A-Overflow.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Gnu C Reference Manual</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../Preface/">前言</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Lexical-Elements/">1. 词法元素</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Data-Types/">2. 数据类型</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Expressions-And-Operators/">3. 表达式与操作符</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Statement/">4. 语句</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Function/">5. 函数</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Program-Structure-And-Scope/">6. 程序结构和作用域</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../A-Sample-Program/">7. 示例程序</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">附录A：溢出</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#Integer-Overflow-Basics">A.1 整数溢出基础</a></li>
    

    <li class="toctree-l2"><a href="#Signed-Overflow-Examples">A.2 假定包装溢出的示例代码</a></li>
    

    <li class="toctree-l2"><a href="#Optimization-and-Wraparound">A.3 中止包装运算的优化</a></li>
    

    <li class="toctree-l2"><a href="#Signed-Overflow-Advice">A.4 关于有符号整数溢出的实践建议</a></li>
    

    <li class="toctree-l2"><a href="#Signed-Integer-Division">A.5 有符号整数除法和取余溢出</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../License/">License</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Gnu C Reference Manual</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>附录A：溢出</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>【本附录内容由 Paul Eggert 写在 GNU Autoconf 手册。我们认为把它放在这里会有帮助。 -- TJR】</p>
<p>实践中，很多可移植的 C 程序假定有符号整数溢出都使用补码运算包装了。但至今 C 标准都说程序的溢出是未定义行为，并且一小部分 C 程序在现代编译器实现不能工作，因为程序中的溢出行为没有像作者期望的那样包装。相反，对于有符号整数的取余，C 标准指定的溢出行为通常都没有被实现。</p>
<ul>
<li><a href="#Integer-Overflow-Basics">Integer Overflow Basics</a>:          为什么整数溢出成为一个问题</li>
<li><a href="#Signed-Overflow-Examples">Signed Overflow Examples</a>:        假定包装的例子</li>
<li><a href="#Optimization-and-Wraparound">Optimization and Wraparound</a>:  停止使用包装的优化</li>
<li><a href="#Signed-Overflow-Advice">Signed Overflow Advice</a>:            关于有符号整数溢出的实用建议</li>
<li><a href="#Signed-Integer-Division">Signed Integer Division</a>:          <code>INT_MIN / -1</code> 和 <code>INT_MIN % -1</code></li>
</ul>
<h3 id="Integer-Overflow-Basics">A.1 整数溢出基础<a class="headerlink" href="#Integer-Overflow-Basics" title="Permanent link">&para;</a></h3>
<p>在类似 C 的语言中，无符号整数溢出可靠地包装；例如：<code>UINT_MAX + 1</code> 得到 0。C 标准保证了这一点，并且在实践中是可移植的，除非你指定了侵入性的只适用于特定程序的非标准优化选项。</p>
<p>相反，C 标准说有符号整数溢出会导致未定义行为，此时程序可以做任何事情，包括核心转储或者溢出缓冲区。不当行为甚至会导致溢出。这样的溢出可以在加、减、乘、除和左移时发生。</p>
<p>很多 C 程序无视 C 标准的需求，假定你要把结果转成有符号整型或者存到有符号整型变量里，有符号整数的溢出会隐式使用补码运算包装在对 2 的幂取模里。如果你使用保守的优化选项，这样的程序通常对于主流的现代平台都是可移植的，但又一些例外，我们随后讨论。</p>
<p>由于历史原因，C 标准允许使用反码或者符号化数值运算的实现，但到今天都认同补码是安全的。</p>
<p>此外，溢出会在把一个超范围的值转成有符号整型。这种情况，一个标准的实现必须定义发生了什么，但这可能包括抛出一个异常。实际上，对这种情况，所有已知的实现都支持隐式地包装，因此你不必担心其他可能。</p>
<h3 id="Signed-Overflow-Examples">A.2 假定包装溢出的示例代码<a class="headerlink" href="#Signed-Overflow-Examples" title="Permanent link">&para;</a></h3>
<p>长期以来，C 标准要求的有符号整型溢出行为和 C 程序通常假设的行为有一些出入。标准允许基于溢出不会发生的假设的侵入式优化，但许多程序却依赖溢出包装。这些程序不符合标准，但通常都能工作，因为编译器作者显然不愿意实现会中断程序的优化，除非用户指定了侵入式优化。</p>
<p>C 标准说如果程序有有符号整型溢出，那它的行为是未定义的，并且该未定义行为甚至可能造成溢出。例如：</p>
<pre><code>if (password == expected_password)
    allow_superuser_privileges ();
else if (counter++ == INT_MAX)
    abort ();
else
    printf (&quot;%d password mismatches\n&quot;, counter);
</code></pre>

<p>如果 <code>int</code> 变量 <code>counter</code> 等于 <code>INT_MAX</code>，则 <code>counter++</code> 一定会溢出，而该行为是未定义的，因此 C 标准允许编译器把和 <code>INT_MAX</code> 的比较和 <code>abort</code> 函数调用优化掉。更糟糕的是，如果程序中更早的一个 bug 让编译器推断出 <code>counter == INT_MAX</code> 或者 <code>counter</code> 之前就溢出了，C 标准允许编译器把 password 的测试也优化掉；这样生成的代码无条件地允许超级用户权限。</p>
<p>抛开标准的这个要求不说，很长一段时间 C 代码都假设在有符号整数溢出发生之后会有包装运算，而所有的已知 C 实现支持一些假设会包装溢出的 C 方言，即使这些方言和标准完全不符。像下面示例中的代码，在现实世界的编译器中绝对可以工作：</p>
<p>下面的代码来自于第七版 Unix 的 <code>atoi</code> 实现（1979-01-10）：</p>
<pre><code>char *p;
int f, n;
…
while (*p &gt;= '0' &amp;&amp; *p &lt;= '9')
    n = n * 10 + *p++ - '0';
return (f ? -n : n);
</code></pre>

<p>即使输入的字符串在范围内，当计算最大负数的时候（即 <code>-n</code> 溢出）或者计算接近极大整数（正数溢出）在大多数现代机器上还是有有符号整数溢出问题。</p>
<p>下面的例子来自第七版 Unix 的 <code>rand</code> 实现(1979-01-10)。该程序期望乘和加会包装溢出：</p>
<pre><code>static long int randx = 1;
…
randx = randx * 1103515245 + 12345;
return (randx &gt;&gt; 16) &amp; 077777;
</code></pre>

<p>下面的例子来自 GNU C 库 2.5 的 <code>mktime</code> 实现（2006-09-09），该代码假设 <code>+</code> 运算符包装溢出来检查有符号数溢出：</p>
<pre><code>time_t t, t1, t2;
int sec_requested, sec_adjustment;
…
t1 = t + sec_requested;
t2 = t1 + sec_adjustment;
if (((t1 &lt; t) != (sec_requested &lt; 0))
    || ((t2 &lt; t1) != (sec_adjustment &lt; 0)))
    return -1;
</code></pre>

<p>如果你的代码像这样，那它基本是安全的，即使不符合 C 标准。这可能会让人以为可以假定溢出会被包装，但并不是这样的，就像下一节看到的。</p>
<h3 id="Optimization-and-Wraparound">A.3 中止包装运算的优化<a class="headerlink" href="#Optimization-and-Wraparound" title="Permanent link">&para;</a></h3>
<p>有时候编译器生成的代码并不包装整数运算。一个简单的例子是代数化简：编译器可能会把 <code>(i * 2000) / 1000</code> 翻译成 <code>i * 2</code>，因为它假定 <code>i * 2</code> 不会溢出。当溢出发生时，翻译结果就不等于原来的含义了：例如，对于典型的 32 位有符号补码包装的整型的情况，如果 <code>i</code> 的类型是 <code>int</code> 并且值是 1073742，原来表达式得到的是 -2147483，但优化后得到的是算术上正确的 2147484。</p>
<p>更微妙地，循环归纳优化更容易暴露出有符号溢出的未定义行为。看下面这个故意设计的函数 <code>sumc</code>：</p>
<pre><code>int
sumc (int lo, int hi)
{
    int sum = 0;
    int i;
    for (i = lo; i &lt;= hi; i++)
        sum ^= i * 53;
    return sum;
}
</code></pre>

<p>为了避免每一次循环都乘 53，编译器可能在内部把 <code>sumc</code> 转换成了：</p>
<pre><code>int
transformed_sumc (int lo, int hi)
{
    int sum = 0;
    int hic = hi * 53;
    int ic;
    for (ic = lo * 53; ic &lt;= hic; ic += 53)
        sum ^= ic;
    return sum;
}
</code></pre>

<p>这个转换是遵循 C 标准的，但当 <code>INT_MAX / 53 &lt; hi</code> 成立时包装运算是非法的，因为计算像 <code>hi * 53</code> 这样的表达式时溢出可能会造成表达式 <code>i &lt;= hi</code> 生成的值和转换后的表达式 <code>ic &lt;= hic</code> 不同。</p>
<p>因此，当涉及像 <code>ic</code> 这样的循环归纳变量时，使用循环归纳和相似技术的编译器通常不支持可靠的包装运算。既然循环归纳变量是编译器生成的，而在源代码中不可见，因此并不总是简单的说该问题是否影响你的代码。</p>
<p>在像这样的例子中，实际几乎没有任何代码依赖包装运算，因此这些循环归纳优化总是很有用的。然而，一些边缘情况还是会产生问题的。如：</p>
<pre><code>int j;
for (j = 1; 0 &lt; j; j *= 2)
    test (j);
</code></pre>

<p>这里，该循环尝试迭代所有 <code>int</code> 类型能表示的 2 的幂，但是 C 标准允许编译器把比较优化掉，在溢出行为未定义的情况下生成无限循环的代码。由此，任何生产版本的带 <code>-O2</code> 的GCC 都没有实现这个，但是其他编译器或更多的侵入式的 GCC 优化选项可能会做。并且 GCC 开发者还没有决定它是否将继续和 <code>-O2</code> 的 GCC 一起工作。</p>
<h3 id="Signed-Overflow-Advice">A.4 关于有符号整数溢出的实践建议<a class="headerlink" href="#Signed-Overflow-Advice" title="Permanent link">&para;</a></h3>
<p>理想情况下，最安全的方法是完全避免有符号整数溢出。例如，不要直接把 2 个有符号整数相乘，而是先把他们转成无符号整数再乘，然后测试结果是否是有符号数。</p>
<p>用这种方式重写代码很不方便，尤其是在该有符号数是负数的时候。此外，还会有性能问题。在处理像 <code>uid_t</code> 这样的宽度和符号性在各个平台都不一样的整数类型，使用无符号运算来检查溢出通常在移植和效率上都成问题。</p>
<p>此外，很多 C 应用普遍假定包装行为，并且通常也很难找出并溢出所有使用这些假设的地方。因此，维持假定溢出包装的非标准代码还是很有用的，而不是重写它。本节剩余部分尝试给这个问题一些实际建议。</p>
<p>如果你想要检测在 <code>sum = a + b</code> 中是否有有符号整型溢出，使用像 <code>(sum &lt; a) != (b &lt; 0)</code> 这样的代码通常是安全的。</p>
<p>如果你的代码使用有符号循环索引，确保该索引还有使用该索引的表达式不能溢出。这里有一个设计好的 2 种溢出实例的问题代码：</p>
<pre><code>for (i = INT_MAX - 10; i &lt;= INT_MAX; i++)
    if (i + 1 &lt; 0)
    {
        report_overflow ();
        break;
    }
</code></pre>

<p>由于这 2 种溢出，编译器可能会使用不兼容的包装假设来优化掉或者转换这 2 个比较。</p>
<p>如果你的代码使用像 <code>(i * 2000) / 1000</code> 这样的表达式，并且你实际想要乘法包装溢出，使用无符号运算来做，如 <code>((int) (i * 2000u)) / 1000</code>。</p>
<p>如果你的代码假设包装行为，并且你想将其与任何不支持该行为的 GCC 优化隔离，你应该使用 GCC 的 <code>-fwrapv</code> 选项，这会可靠地包装有符号溢出（不包括除法和取余，下节讨论）。</p>
<p>如果你需要介入有符号整型包装不可靠的平台（例如，由于硬件溢出检查，或者高度侵入优化），你应该考虑使用 GCC 的 <code>-ftrapv</code> 选项调试，它会在有符号溢出时抛出异常。</p>
<h3 id="Signed-Integer-Division">A.5 有符号整数除法和取余溢出<a class="headerlink" href="#Signed-Integer-Division" title="Permanent link">&para;</a></h3>
<p>有符号整数除法溢出并不总是无害的：例如，在 i386 家族的 CPU 上，用 <code>-1</code> 去除 <code>INT_MIN</code> 会产生 SIGFPE 信号，其默认行为是终止程序。更糟糕的是，这 2 个数取余通常产生同样的信号，尽管 C 标准要求 <code>INT_MIN % -1</code> 为 0 因为该表达式并没有溢出。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../License/" class="btn btn-neutral float-right" title="License">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../A-Sample-Program/" class="btn btn-neutral" title="7. 示例程序"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../A-Sample-Program/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../License/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
