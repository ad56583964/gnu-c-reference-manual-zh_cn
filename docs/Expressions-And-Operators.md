### 3.1 表达式 { #Expressions }

一个*表达式*由至少一个操作数和 0 个或多个操作符组成。操作数是有类型的对象，如常量、变量以及有返回值的函数调用。例如：

```
47
2 + 2
cosine(3.14159) /* 
We presume this returns a floating point value.
 */
```

圆括号分组的子表达式:

```
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
```

最内层的表达式最先计算。上面的例子中，`3 + 10` 和 `2 * 6` 分别计算为 `13` 和 `12`。然后 `13` 减去 `12`，得到 `1`。最后 `1` 乘上 `2` 得到 `2`。最外层的圆括号是可选的。

一个*操作符*给它的*操作数*指定一个操作。不同操作符可能有 1 个，2 个或者 3 个操作数。


### 3.2 赋值操作符 { #Assignment-Operators }

赋值操作符把一个值存到变量里面。 C 提供了多种赋值操作符。

标准赋值操作 `=` 符简单地把右边的操作符存到左边的变量里面。和所有的赋值操作符一样，左操作数（通常也叫左值）不能是字面量或常值。

```
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo {
    int bar;
    int baz;
} quux = {3, 4};
```

注意，不像下面那些赋值操作符，你可以用 `=` 来赋值结构体类型。

组合赋值操作符先对左右 2 个操作数进行操作，然后将结果赋给左操作数。下面列出了组合赋值操作符和它们的简要说明：

- `+=`

    先相加，再把结果赋值。

- `-=`

    先把左操作数减去右操作数，再把结果赋值。

- `*=`

    先相乘，再把结果赋值。

- `/=`

    先把左操作数除以右操作数，再把结果赋值。

- `%=`

    先把左操作数模右操作数，再把结果赋值。

- `<<=`

    先把左操作数左移右操作数个位，再把结果赋值。

- `>>=`

    先把左操作数右移右操作数个位，再把结果赋值。

- `&=`

    先按位与，再把结果赋值。

- `^=`

    先按位异或，再把结果赋值。

- `|=`

    先按位或，再把结果赋值。

下面是一个组合赋值操作符的例子：

```
x += y;
```

既然计算左值 `x` 没有副作用，那下面的代码可以写成：

```
x = x + y;
```

### 3.3 自增和自减 { #Incrementing-and-Decrementing }

自增操作符 `++` 会将它的操作数加 1。该操作数可以是一个基本数据类型的变量，一个指针，或者一个枚举变量。你也可以把自增操作符放在操作数前面或者后面。例如：

```
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

++w;   /* w is now the character ‘2’ (not the value 2). */
x++;   /* x is now 6. */
++y;   /* y is now ‘C’ (on ASCII systems). */
z++;   /* z is now 6.2. */
++p;   /* p is now &x + sizeof(int). */
```

（注意，对一个指针使用自增只有在你确信新的指针值是一个合法内存地址时才有意义）

前置自增操作符会在操作数被计算前加 1. 而后置自增操作在操作数被计算后加 1。对于上面的例子，改变自增操作符的位置是没有区别的。然而，对于下面的例子，他们是不同的：

```
int x = 5;
printf ("%d \n", x++);    /* Print x and then increment it. */
/* x is now equal to 6. */
printf ("%d \n", ++x);    /* Increment x and then print it. */
```

上面例子的结果是：

```
5
7
```

同样你可以使用自减操作符使操作数减 1：

```
int x = 5;

x--; /* x is now 4. */
```

自减操作符也有前置和后置的概念。

### 3.4 算术运算操作符 { #Arithmetic-Operators }

C 提供标准算术运算操作符：加减乘除，还有取模和相反数。这些操作符用法很直接；例如：

```
/* Addition. */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
/* Subtraction. */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
```

指针可以加减，但不能乘除。

```
/* Multiplication. */
x = 5 * 3;
y = 47.4 * 1.001;
/* Division. */
x = 5 / 3;
y = 940.0 / 20.2;
```

正数的整数除向 0 截断，如 `5/3` 等于 `1`。然而，如果操作数是负的，截断方向由具体实现定义。关于有符号整数除的溢出问题详见 [有符号整数除法](Appendix-A-Overflow.md#Signed-Integer-Division)

你可以使用取模操作符 `%` 来计算 2 个操作数的余数，并且操作数是有方向的： `3 % 5` 和 `5 % 3` 是不同的。操作数必须是基础数据类型表达式。

```
/* Modular division. */
x = 5 % 3;
y = 74 % 47;
```

取模除得到 2 个操作数相除后的余数。操作数必须是基础整数类型。

```
/* Negation. */
int x = -5;
float y = -3.14159;
```

如果你对一个 unsigned 类型的操作数使用相反数操作符，得到的结果不是相反数，而是该 unsigned 类型的最大值减去该操作数。

很多系统使用补码运算，因此在这些系统上 signed 类型的最小负数的相反数比最大整数要大。例如：

```
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
{
    int x;
    x = INT_MAX;
    printf("INT_MAX  = %d\n", x);
    x = INT_MIN;
    printf("INT_MIN  = %d\n", x);
    x = -x;
    printf("-INT_MIN = %d\n", x);
    return 0;
}
```

输出的结果是：

```
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
```

你也可以在一个数字表达式前面加上整数操作数 +，但并没有意义：

```
int x = +42;
```

数值总是被假定为整数，除非你明确地加了符号，因此，这个操作符没有任何作用。

### 3.5 复数共轭 { #Complex-Conjugation }

GNU 扩展让你可以使用复数共轭操作符 `~` 来对一个复数操作符取共轭 -- 即转换虚部的符号。操作数必须是一个复数类型表达式。例如：

```
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));

```

因为复数 *(a + bi)* 乘以它的共轭等于 *a^2 + b^2*。所以，上面 `printf` 将会打印 314，即 *25 + 289*。

### 3.6 比较操作符 { #Comparison-Operators }

你使用比较操作符来确定 2 个操作数的相对关系：是相等，还是一个比另外一个大，还是一个比另外一个小，等等。当你使用比较操作符时，结果要么是 1 要么是 0， 分别代表真和假。

（在下面的代码示例中，变量 `x` 和 `y` 代表 2 个算术类型的表达式或者指针）

相等操作符 == 测试 2 个操作数是否相等。结果 1 代表相等，0 代表不等。

```
if (x == y)
    puts ("x is equal to y");
else
    puts ("x is not equal to y");
```

不等操作符 != 测试 2 个操作数是否不相等。结果 1 代表不相等，0 代表相等。

```
if (x != y)
    puts ("x is not equal to y");
else
    puts ("x is equal to y");
```

比较浮点数相等或者不等可能会得到意想不到的结。详见 [实数类型](Data-Types.md#Real-Number-Types)

你可以比较 2 个函数指针是否相等；该比较会测试 2 个指针是否指向同一个函数。

除了相等和不等，下面的操作符可以用来测试一个值是否小于、大于、小于等于或者大于等于另外一个值。下面是示例：

```
if (x < y)
    puts ("x is less than y");
if (x <= y)
    puts ("x is less than or equal to y");
if (x > y)
    puts ("x is greater than y");
if (x >= y)
    puts ("x is greater than or equal to y");
```

### 3.7 逻辑操作符 { #Logical-Operators }

逻辑操作符测试一对操作数的真值。在 C 中，任何非 0 表达式都是真，相反都是假。

逻辑与操作符 `&&` 测试 2 个操作数是否都是真。如过第一个表达式为假，则第二个表达式将不会被计算。

```
if ((x == 5) && (y == 10))
    printf ("x is 5 and y is 10");
```

逻辑与操作符 `||` 测试 2 个操作数是否至少有一个为真。如过第一个表达式为真，则第二个表达式将不会被计算。

```
if ((x == 5) || (y == 10))
    printf ("x is 5 or y is 10");
```

你可以在逻辑表达式前面加一个逻辑非操作符 `!` 来反转该表达式的真值：

```
if (!(x == 5))
    printf ("x is not 5");
```

因为逻辑表达式对的第二个操作数不是总会被计算，所以你不能写下面这种不直观的代码：

```
if (foo && x++)
    bar();
```

如果 `foo` 是 0，不仅 `bar` 函数不会被调用，`x` 也不会自增。如果你打算不管 `foo` 的值是什么都要自增 `x`，你应该把它写到逻辑与表达式外面。

### 3.8 位移 { #Bit-Shifting }

你使用左移操作符 `<<` 把它的第一个操作数向左移位。第二个操作数代表要移多少位。移出左边界的位将被丢弃，右侧新加入的位为 0.

```
x = 47;    /* 47 is 00101111 in binary. */
x << 1;    /* 00101111 << 1 is 01011110. */
```

类似地，你使用右移操作符 `>>` 把它的第一个操作数向右移位。第二个操作数代表要移多少位。移出右边界的位将被丢弃，左侧新加入的位*通常*为 0. 但如果第一个操作数是一个有符号的负数，那么新加的位会是 0 *或者* 之前最左边位置的值。

```
x = 47;   /* 47 is 00101111 in binary. */
x >> 1;   /* 00101111 >> 1 is 00010111. */
```

对于 `<<` 和 `>>` ，如果第二个操作数比第一个操作数的位宽还要大，或者第二个操作数是复数，该行为是未定义的。

你可以使用移位操作数来做一些有趣的 hack 操作。例如，给你一个日期包含天 `d`，月 `m` 和年 `y`，你可以把它存到一个数 `x` 里面：

```
int d = 12;
int m = 6;
int y = 1983;
int x = (((y << 4) + m) << 5) + d;
```

你也可以使用移位操作符和取模来把原来的 `d`、`m`、`y` 从 `x` 里面提取出来：

```
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
```

### 3.9 位逻辑操作符 { #Bitwise-Logical-Operators }

C 提供了按位与，按位或，按位异或和按位取反操作符。

按位与测试 2 个操作数的每一位，对应位都为 1 则该位结果为 1。其他情况都为 0。下面用二进制数来演示如何工作：

```
11001001 & 10011011 = 10001001
```

按位或测试 2 个操作数的每一位，对应位都为 0 则该位结果为 0。其他情况都为 1。

```
11001001 | 10011011 = 11011011
```

按位异或测试 2 个操作数的每一位，对应位不同则该位结果为 1。其他情况都为 0。

```
11001001 ^ 10011011 = 01010010
```

按位取反反转它的操作数的每一位：

```
~11001001 = 00110110
```

在 C 里面，这些操作符只能用于整数类型（或字符类型)，并且为了最大的可移植性，你应该只对 unsiged 整数类型使用按位取反操作符。例如：

```
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
```

### 3.10 指针操作符 { #Pointer-Operators }

你可以使用地址操作符 `&` 来获取一个对象的内存地址。

```
int x = 5;
int *pointer_to_x = &x;
```

使用 `&` 来获取一个函数的地址是不必要的，尽管你可以：

```
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 points to foo */
int (*fp2) (void) = &foo; /* fp2 also points to foo */
```

函数指针和数据指针是不兼容的，因此你不能把函数的地址存进数据指针，然后拷贝到函数指针并成功调用它。有可能在某些系统上可以工作，但这是不可移植的。

GNU 的 C89 的扩展中，你还可以使用标签地址操作符 `&&` 来获取一个标签的地址。结果是一个 `void*` 指针，可以用于 `goto` 语句。详见 [goto 语句](Statement.md#The-goto-Statement)

假定一个内存地址存储在一个指针里，你可以使用间接运算符 `*` 来获取存在该地址的值（这被称作解引用指针）

```
int x = 5;
int y;
int *ptr;

ptr = &x;    /* ptr now holds the address of x. */

y = *ptr;    /* y gets the value stored at the address
                stored in ptr. */
```

要避免解引用一个没有初始化为已知内存地址的指针。


### 3.11 sizeof 操作符 { #The-sizeof-Operator }

你可以使用 `sizeof` 操作符来获取它的操作数的数据类型的大小（按字节）。操作数可以是类型指示符（如 `int` 或 `float`）,也可以是任何合法表达式。当操作数是类型名字时，它必须放在圆括号里。如：

```
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
```

`sizeof` 的结果是 `size_t` 类型，它在头文件 `<stddef.h>` 中定义。`size_t` 是无符号整数类型，它可能是 `unsigned int` 或者 `unsigned long int`，取决于你的系统。

`size_t` 作为循环的下标很方便，因为它能保证放下任何数组的大小；但 `int` 不行。

`sizeof` 操作符可以用来计算数组元素的个数：

```
#include <stddef.h>
#include <stdio.h>

static const int values[] = { 1, 2, 48, 681 };
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    {
        printf("%d\n", values[i]);
    }
    return 0;
}
```

有 2 种情况这种技术不能工作。第一种是数组的元素的大小为 0（GNU 扩展支持大小为 0 的结构）。第二种是数组是一个函数的参数（详见 [函数参数](Function.md#Function-Parameters))。

### 3.12 类型转换 { ##Type-Casts }

你可以使用类型转换显式地将一个表达式变成指定的数据类型。一个类型转包括一个圆括号括起来的类型指示符，后跟一个表达式。为了确保正确的转换，你应该给后面跟的表达式也加一个圆括号。例如：

```
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
```

在这个例子中，因为 `y` 和 `z` 都是整型，所以 y / z 是整数除；即使 `x` 是浮点型，它也接受值 2。显式转换除法的结果为 `float` 类型并不好，因为 y / z 的值已经是 2 了。

为了修复这个问题，你需要把除法的一个操作数在除法进行之前转成浮点型：

```
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
```

这里，一个接近 2.333· 的浮点数被赋给了 `x`。

类型转换只对表标量有用（像整型，浮点型或指针类型）。因此，下面这种是不允许的：

```
struct fooTag { /* members ... */ };
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* Fail! */
```

### 3.13 数组下标 { #Array-Subscripts }

你可以通过指定数组名字和方括号括起来的数组下标（或者叫索引，或者叫元素数）的形式来访问数组元素。例如，假设有一个叫 `my_array` 的整型数组：

```
my_array[0] = 5;
```

数组下标表达式 `A[i]` 被定义为和表达式 `(*((A)+(i)))` 是一样的。这意味着很多数组名的使用和指针表达式是等价的。也就意味着你不能对一个 `register` 限定的数组使用下标。


### 3.14 函数调用作为表达式 { #Function-Calls-as-Expressions }

任何返回一个值的函数调用都是一个表达式。

```
int function(void);
…
a = 10 + function();
```

### 3.15 逗号操作符 { #The-Comma-Operator }

你可以使用逗号操作符 `,` 来分割 2 个（表面上相关的）表达式。比如，第一个表达式可能会产生一个被第二个表达式使用的值：

```
x++, y = x * x;
```

更常见地，逗号操作符被用于 `for` 语句，像下面这样：

```
/* Using the comma operator in a for statement. */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
{
    …
}
```

这让你很方便地设置，监控以及修改 `for` 语句中的多个控制表达式。

逗号也被用于分割函数参数；然而，这里的逗号在行为上就不是逗号操作符了。实际上，如果逗号操作符被用于函数调用，那么编译器将解释成使用一个额外的参数（即多了一个参数）来调用函数。

如果你想在函数参数里面使用逗号操作符，那你必须用圆括号括起来。这是因为在函数参数里逗号有不同的含义：用来分割参数。因此，

```
foo (x,  y=47,  x,  z);
```

被解释成使用 4 个参数的函数调用；但是，

```
foo (x,  (y=47,  x),  z);
```

就是一个只有三个参数的函数调用（第二个参数是 (y = 47, x)）。


### 3.16 成员访问表达式 { #Member-Access-Expressions }

你可以使用成员访问操作符 `.` 来访问结构体或者联合体变量的成员。你要把结构体变量的名字放在操作符左边，成员名字放在右边。

```
struct point
{
    int x, y;
};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
```

你也可以通过指针来访问结构体或联合体变量的成员，要使用间接成员访问操作符 `->`。 `x->y` 等价于 `(*x).y`。

```
struct fish
{
    int length, weight;
};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
```

详见 [指针](Data-Types.md#Pointers)


### 3.17 条件表达式 { #Conditional-Expressions }

使用条件运算符可以让你通过条件表达式去决定是计算第二个操作数还是第三个操作数，这取决于第一个操作数的真值。例如：

```
a ? b : c
```

如果表达式 `a` 是真，则表达式 `b` 被计算并且结果是 `b` 的值。否则，表达式 `c` 被计算，结果是 `c`。

表达式 `b` 和 `c` 一定要兼容。也就是说，他们必须都是：

1. 算术类型
2. 兼容的 `struct` 或 `union` 类型
3. 指向兼容类型的指针（其中一个可以是 NULL 指针）

此外，可以一个操作数是指针，另外一个是 `void*` 指针。

例如：

```
a = (x == 5) ? y : z;
```

这里，如果 `x` 等于 5，那么 `a` 将得到 `y` 的值。否则，`a` 将得到 `z` 的值。这可以被认为是一个 `if...else` 表达式的简写。下面的代码实现了同样的功能：

```
if (x == 5)
    a = y;
else
    a = z;
```

如果条件操作符的第一个操作数是真，那么第三个操作数将不会被计算。类似的，如果第一个操作数是假，那第二个操作数不会被计算。而第一个操作数总是会被计算。


### 3.18 表达式中的语句和声明 { #Statements-and-Declarations-in-Expressions }

作为 GNU C 扩展，你可以使用圆括号括起来的组合语句来构建一个表达式。这里允许你在一个表达式里包含循环、switch 和局部变量。

回想一下，一个组合语句（或者叫代码块）是一系列用花括号包裹的语句。而在本节的构架下，圆括号要把花括号包起来。例如：

```
({ int y = function (); int z;
    if (y > 0) z = y;
    else z = - y;
    z; })
```

这是合法的（尽管比起必要的写法更复杂的）求 `function()` 绝对值的表达式。

组合表达式最后应该是一个跟着分号的表达式；该表达式的值将是整个结构的值。（如果你在花括号最后使用了其他类型的语句，该结构则是 `void` 类型，因此等效于无值）

这个特性在定义“安全”宏定义时尤其有用（以至于它们仅计算每一个操作数一次）。例如，“求最大值”函数通常在标准 C 中使用宏作如下定义：

```
#define max(a,b) ((a) > (b) ? (a) : (b))
```

但是该定义计算 `a` 或 `b` 两次，如果操作数有副作用就会得到一个坏结果。在 GNU C 中，如果你知道操作数的类型（这里我们假设为 `int`），你可以像下面这样安全地定义宏：

```
#define maxint(a,b) \
    ({int _a = (a), _b = (b); _a > _b ? _a : _b; })
```

如果你不知道操作数的类型，你仍可以这么做，但你必须使用 `typeof` 表达式或者类型名。

嵌入语句不需要用在常量表达式，如枚举常量的值，位域的宽度或者一个静态变量的初始值。


### 3.19 操作符优先级 { #Operator-Precedence }

当表达式包含多个操作符，如 `a + b * f()`，这些操作符会根据*优先级*规则进行分组。例如，这个表达式的含义就是先没有参数地调用函数 `f`，用结果乘以 `b`，然后把结果加上 `a`。这是 C 的运算符优先级规则决定了这个表达式。

下面是表达式类型列表，要优先级从高到低排序。有时 2 个或多个运算符有相同的优先级；所有这些运算符都是从左到右结合，除非另有说明。

1. 函数调用，数组下标，和成员访问运算符表达式
2. 一元运算符，包括逻辑非，按位取反，自增，自减，一元正，一元负，间接运算符，地址运算符，类型转换和 sizeof 表达式。当多个一元运算符连着写，后面的是嵌套在里面的：!-x 相当于 !(-x)
3. 乘、除和取模表达式
4. 加和减表达式
5. 移位表达式
6. 大于，小于，大于等于和小于等于表达式
7. 等于和不等于表达式
8. 按位与表达式
9. 按位异或表达式
10. 按位或表达式
11. 逻辑与表达式
12. 逻辑或表达式
13. 条件表达式（使用 ?:）。当使用子表达式时，子表达式从右向左计算
14. 所有的赋值表达式，包括组合赋值。当多个赋值语句作为一个大的表达式的子表达式出现，他们从右向左计算。
15. 逗号运算符表达式

上面这个列表有点干，显得很直接，但它隐藏了一些陷阱。例如：

```
foo = *p++;
```

这里 `p` 作为表达式的副作用被自增，但是 `foo` 得到的是 `*(p++)` 的值，而不是 `(*p)++`，因为一元操作符自右向左结合。还有一些其他的关于 C 优先级表的潜在的陷阱。因此，当读者有任何误解的时候，你都应该使用圆括号来消除误解。

### 3.20 求值顺序 { #Order-of-Evaluation }

在 C 里你不知假定多个子表达式会按照看起来的自然序来求值。例如，对于表达式 `++a * f()`，自增 `a` 是在调用函数 `f` 之前还是之后？编译器也有可能用其他顺序求值，所以你不能做任何假设。

本手册抽象地解释了 C 语言的语义。然而，具体编译器在具体计算机上将源代码翻译成指定动作，并且可能为了效率改变执行顺序。你写的程序和计算机实际做的事情之间的对应由副作用和序列点而定。

#### 3.20.1 副作用 { #Side-Effects }

副作用是指：

1. 访问一个 `volatile` 对象
2. 修改一个对象
3. 修改一个文件
4. 调用了一个包含上面任何一个副作用的函数

这些在本质上是外部可见的运行程序的副作用。被称为副作用是因为它们是表达式求值的效果，而不是该表达式实际的结果值。

编译器允许执行程序的操作顺序和源文件中暗含的顺序不同，只要在最后所有需要的副作用都发生了。编译器也允许完全省略一些计算；例如，它允许跳过计算部分表达式，如果可以确定该表达式的计算结果不会被用到并且计算该表达式不会产生任何需要的副作用。

#### 3.20.2 序列点 { #Sequence-Points }

编译器另外的要求是副作用应该按照正确的顺序发生。为了提供这个而不会过度约束编译器，C89 和 C99 标准指定了一些序列点。一个序列点就是下面其中之一：

1. 一次函数调用（在参数被计算完成之后）
2. 与运算符 `&&` 的左操作数计算完成
3. 或运算符 `||` 的左操作数计算完成
4. 逗号运算符 `,` 的左操作数计算完成
5. 三目运算符 `a ? b : c` 的第一个操作数计算完成
6. 完整的声明结束[^2]
7. 一个初始化表达式结束
8. 一个表达式语句结束（如，一个表达式后跟 `;`）
9. `if` 或 `switch` 语句的控制表达式结束
10. `while` 或 `do` 语句的控制表达式结束
11. `for` 语句的 3 个控制表达式任何一个结束
12. `return` 语句中的表达式结束
13. 在库函数马上返回之前
14. 在和格式化 I/O 相关的（例如常用的 `strftime` 或 `printf` 和 `scanf` 系列函数）动作之后
15. 马上调用一个比较函数之前和之后（如 `qsort`）

在一个序列点，之前表达式计算的副作用必须都完成，并且后面计算的副作用还没有发生。

这看起来有点难理解，但是可以换个方式去思考它。想象一下你写了一个库（其中一些函数式外部的，一些不是），然后编译它，并允许其他人在他们的代码中调用你的函数。上面的定义则确保了，在他们调用你的函数时，他们传进来的数据拥有和抽象机指定的行为一致的值，并且任何你的函数返回的数据也都有一个和抽象机保持一致的状态。包括使用指针来访问数据（如，不只是函数参数和拥有外部连接的标识符）。

上面是轻微的简化，因为编译器会在连接时进行真个程序的优化。然而重要的是，尽管可能执行优化，但程序中可见的副作用必须保持相同，就好像它们是由抽象机产生的一样。

#### 3.20.3 序列点约束表达式 { #Sequence-Points-Constrain-Expressions }

代码段

```
i = i + 1;
```

经常出现在程序里。然而，下面这个相似的代码段

```
i = ++i + 1;
```

就有点难理解了；最后 `i` 的值是多少？C 标准（包括 C89 和 C99）都禁止这种写法。

在 2 个序列点之间，

1. 一个对象可能最多通过表达式求值改变它自己的值一次
2. 对象之前的值应该仅被读出来用于计算要被存储的值

第一个条件禁止像 `foo(x=2, ++x)` 这样的表达式。第二个条件禁止像 `a[i++] = i` 的表达式。

- `int x=0; foo(++x, ++x)`

    在合规的程序中不被允许；在参数计算完成前修改了 `x` 两次。

- `int x=0; bar((++x,++x))`

    允许；函数 `bar` 只要一个参数（传过去的是值 2），并且在逗号运算符那里有一个序列点

- `*p++ || *p++`

    允许；`||` 是一个序列点。

- `int x = 1, y = x++;`

    允许；在完整声明 `x` 之后有一个序列点。

- `x=2; x++;`

    允许；在第一个表达式语句结束之后有一个序列点。

- `if (x++ > MAX) x = 0;`

    允许；在 `if`[^3] 语句的控制表达式结束之后有一个序列点。

- `(x=y) ? ++x : x--;`

    允许；在 `?` 之前有一个序列点，并且后面的 2 个表达式只有一个会被计算。

- `int *p=malloc(sizeof(*p)), *q=p; *p=foo(); bar((*p)++,(*q)++);`

    不允许；`p` 指向的对象在函数 `bar` 的参数计算完成前被修改了 2 次。实际上，一次是通过 `p` 修改，另一次通过 `q` 修改，它们是不相干的，因为它们都指向了同一个对象。

让我们回到我们介绍求值顺序的例子 `++a * f()`。假设实际代码是这样的：

```
static int a = 1;

static int f (void)
{
    a = 100;
    return 3;
}

int foo (void)
{
   return ++a * f();
}
```

这个代码在标准合规的程序中允许吗？尽管在 `foo` 中的表达式修改 `a` 2 次，但这没有问题。让我们看 2 个可能的情况。

1. 右边的操作数 `f()` 先计算
  
  既然 `f` 返回一个值而不是 `void`，那它肯定有一个 `return` 表达式。那在 `f` 中修改 `a` 和求值左操作数之间就有了一个序列点。
2. 左操作数 `++a` 先求值

  首先，`a` 被自增。然后 `f` 的参数（这里没有）被求值。那么这里在 `f` 实际运行之前有了一个序列点。

因此，我们认为这个程序是标准合规的。注意的是，上面的参数实际上不依赖于函数 `f` 内部。它值依赖于在序列点结束时包含的内容--在我们的例子中，这是一个 return 语句，此外一个表达式语句或完整的声明也可以。

然而，执行该代码的结果取决于 `*` 的操作数的求值顺序。如果左操作数先求值，`foo` 返回 6.否则，`foo` 返回 303。C 标准并没有指定操作数该以何种顺序求值，并且既不要求编译器指明顺序也不要求编译器只用一种顺序。代码的效果为指定，意味着可能会有很多情况发生，但 C 标准并没有说哪一种。

#### 3.20.4 序列点和信号传递 { #Sequence-Points-and-Signal-Delivery }

信号主要记录在 GNU C Library 手册里，尽管 C 标准把编译器和 C 库一起看做是实现。

信号接收会发生在 2 个序列点之间。前面序列点之前的 `volatile` 对象的副作用将已经完成，但其他更新可能还没有发生。这甚至会出现在直接赋值语句，如果 `x = 0;`，因为这个语句生成代码可能包含不止一条指令，也就意味着它可能被信号传递中断。

C 标准对何种数据访问可以出现在信号处理里面做了相当大的约束。当然可以使用 `auto` 变量，但根据是读或写其他对象，必须是 `volatile sig_atomic_t`。`volatile` 类型限制符确保了访问程序其他部分的变量不会跨越序列点；并且使用 `sig_atomic_t` 类型可以确保在信号传递时对变量的修改是原子的。

POSIX 标准也允许一小部分库函数在信号处理里面被调用。这些函数都是异步安全的。如果你的程序只在 POSIX 系统上运行，你可以安全地在信号处理里面调用它们。

[^2]: 完整的声明符是一个函数声明或者一个对象声明，并且该对象不能是其它对象的一部分
[^3]: 然而如果示例中的 `MAX` 的值为 `INT_MAX` 并且 `x` 的类型是 `int`，那这里有溢出问题。详见 [附录A：溢出](Appendix-A-Overflow.md)
