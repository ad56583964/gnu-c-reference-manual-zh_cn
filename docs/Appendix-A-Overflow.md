【本附录内容由 Paul Eggert 写在 GNU Autoconf 手册。我们认为把它放在这里会有帮助。 -- TJR】

实践中，很多可移植的 C 程序假定有符号整数溢出都使用补码运算包装了。但至今 C 标准都说程序的溢出是未定义行为，并且一小部分 C 程序在现代编译器实现不能工作，因为程序中的溢出行为没有像作者期望的那样包装。相反，对于有符号整数的取余，C 标准指定的溢出行为通常都没有被实现。

- [Integer Overflow Basics](#Integer-Overflow-Basics):          为什么整数溢出成为一个问题
- [Signed Overflow Examples](#Signed-Overflow-Examples):	  	假定包装的例子
- [Optimization and Wraparound](#Optimization-and-Wraparound):  停止使用包装的优化
- [Signed Overflow Advice](#Signed-Overflow-Advice):            关于有符号整数溢出的实用建议
- [Signed Integer Division](#Signed-Integer-Division):          `INT_MIN / -1` 和 `INT_MIN % -1`


### A.1 整数溢出基础 { #Integer-Overflow-Basics }

在类似 C 的语言中，无符号整数溢出可靠地包装；例如：`UINT_MAX + 1` 得到 0。C 标准保证了这一点，并且在实践中是可移植的，除非你指定了侵入性的只适用于特定程序的非标准优化选项。

相反，C 标准说有符号整数溢出会导致未定义行为，此时程序可以做任何事情，包括核心转储或者溢出缓冲区。不当行为甚至会导致溢出。这样的溢出可以在加、减、乘、除和左移时发生。

很多 C 程序无视 C 标准的需求，假定你要把结果转成有符号整型或者存到有符号整型变量里，有符号整数的溢出会隐式使用补码运算包装在对 2 的幂取模里。如果你使用保守的优化选项，这样的程序通常对于主流的现代平台都是可移植的，但又一些例外，我们随后讨论。

由于历史原因，C 标准允许使用反码或者符号化数值运算的实现，但到今天都认同补码是安全的。

此外，溢出会在把一个超范围的值转成有符号整型。这种情况，一个标准的实现必须定义发生了什么，但这可能包括抛出一个异常。实际上，对这种情况，所有已知的实现都支持隐式地包装，因此你不必担心其他可能。

### A.2 假定包装溢出的示例代码 { #Signed-Overflow-Examples }

长期以来，C 标准要求的有符号整型溢出行为和 C 程序通常假设的行为有一些出入。标准允许基于溢出不会发生的假设的侵入式优化，但许多程序却依赖溢出包装。这些程序不符合标准，但通常都能工作，因为编译器作者显然不愿意实现会中断程序的优化，除非用户指定了侵入式优化。

C 标准说如果程序有有符号整型溢出，那它的行为是未定义的，并且该未定义行为甚至可能造成溢出。例如：

```
if (password == expected_password)
    allow_superuser_privileges ();
else if (counter++ == INT_MAX)
    abort ();
else
    printf ("%d password mismatches\n", counter);
```

如果 `int` 变量 `counter` 等于 `INT_MAX`，则 `counter++` 一定会溢出，而该行为是未定义的，因此 C 标准允许编译器把和 `INT_MAX` 的比较和 `abort` 函数调用优化掉。更糟糕的是，如果程序中更早的一个 bug 让编译器推断出 `counter == INT_MAX` 或者 `counter` 之前就溢出了，C 标准允许编译器把 password 的测试也优化掉；这样生成的代码无条件地允许超级用户权限。

抛开标准的这个要求不说，很长一段时间 C 代码都假设在有符号整数溢出发生之后会有包装运算，而所有的已知 C 实现支持一些假设会包装溢出的 C 方言，即使这些方言和标准完全不符。像下面示例中的代码，在现实世界的编译器中绝对可以工作：

下面的代码来自于第七版 Unix 的 `atoi` 实现（1979-01-10）：

```
char *p;
int f, n;
…
while (*p >= '0' && *p <= '9')
    n = n * 10 + *p++ - '0';
return (f ? -n : n);
```
即使输入的字符串在范围内，当计算最大负数的时候（即 `-n` 溢出）或者计算接近极大整数（正数溢出）在大多数现代机器上还是有有符号整数溢出问题。

下面的例子来自第七版 Unix 的 `rand` 实现(1979-01-10)。该程序期望乘和加会包装溢出：

```
static long int randx = 1;
…
randx = randx * 1103515245 + 12345;
return (randx >> 16) & 077777;
```

下面的例子来自 GNU C 库 2.5 的 `mktime` 实现（2006-09-09），该代码假设 `+` 运算符包装溢出来检查有符号数溢出：

```
time_t t, t1, t2;
int sec_requested, sec_adjustment;
…
t1 = t + sec_requested;
t2 = t1 + sec_adjustment;
if (((t1 < t) != (sec_requested < 0))
    || ((t2 < t1) != (sec_adjustment < 0)))
    return -1;
```
如果你的代码像这样，那它基本是安全的，即使不符合 C 标准。这可能会让人以为可以假定溢出会被包装，但并不是这样的，就像下一节看到的。


### A.3 中止包装运算的优化 { #Optimization-and-Wraparound }

有时候编译器生成的代码并不包装整数运算。一个简单的例子是代数化简：编译器可能会把 `(i * 2000) / 1000` 翻译成 `i * 2`，因为它假定 `i * 2` 不会溢出。当溢出发生时，翻译结果就不等于原来的含义了：例如，对于典型的 32 位有符号补码包装的整型的情况，如果 `i` 的类型是 `int` 并且值是 1073742，原来表达式得到的是 -2147483，但优化后得到的是算术上正确的 2147484。

更微妙地，循环归纳优化更容易暴露出有符号溢出的未定义行为。看下面这个故意设计的函数 `sumc`：

```
int
sumc (int lo, int hi)
{
    int sum = 0;
    int i;
    for (i = lo; i <= hi; i++)
        sum ^= i * 53;
    return sum;
}
```

为了避免每一次循环都乘 53，编译器可能在内部把 `sumc` 转换成了：

```
int
transformed_sumc (int lo, int hi)
{
    int sum = 0;
    int hic = hi * 53;
    int ic;
    for (ic = lo * 53; ic <= hic; ic += 53)
        sum ^= ic;
    return sum;
}
```
这个转换是遵循 C 标准的，但当 `INT_MAX / 53 < hi` 成立时包装运算是非法的，因为计算像 `hi * 53` 这样的表达式时溢出可能会造成表达式 `i <= hi` 生成的值和转换后的表达式 `ic <= hic` 不同。

因此，当涉及像 `ic` 这样的循环归纳变量时，使用循环归纳和相似技术的编译器通常不支持可靠的包装运算。既然循环归纳变量是编译器生成的，而在源代码中不可见，因此并不总是简单的说该问题是否影响你的代码。

在像这样的例子中，实际几乎没有任何代码依赖包装运算，因此这些循环归纳优化总是很有用的。然而，一些边缘情况还是会产生问题的。如：

```
int j;
for (j = 1; 0 < j; j *= 2)
    test (j);
```
这里，该循环尝试迭代所有 `int` 类型能表示的 2 的幂，但是 C 标准允许编译器把比较优化掉，在溢出行为未定义的情况下生成无限循环的代码。由此，任何生产版本的带 `-O2` 的GCC 都没有实现这个，但是其他编译器或更多的侵入式的 GCC 优化选项可能会做。并且 GCC 开发者还没有决定它是否将继续和 `-O2` 的 GCC 一起工作。

### A.4 关于有符号整数溢出的实践建议 { #Signed-Overflow-Advice }

理想情况下，最安全的方法是完全避免有符号整数溢出。例如，不要直接把 2 个有符号整数相乘，而是先把他们转成无符号整数再乘，然后测试结果是否是有符号数。

用这种方式重写代码很不方便，尤其是在该有符号数是负数的时候。此外，还会有性能问题。在处理像 `uid_t` 这样的宽度和符号性在各个平台都不一样的整数类型，使用无符号运算来检查溢出通常在移植和效率上都成问题。

此外，很多 C 应用普遍假定包装行为，并且通常也很难找出并溢出所有使用这些假设的地方。因此，维持假定溢出包装的非标准代码还是很有用的，而不是重写它。本节剩余部分尝试给这个问题一些实际建议。

如果你想要检测在 `sum = a + b` 中是否有有符号整型溢出，使用像 `(sum < a) != (b < 0)` 这样的代码通常是安全的。

如果你的代码使用有符号循环索引，确保该索引还有使用该索引的表达式不能溢出。这里有一个设计好的 2 种溢出实例的问题代码：

```
for (i = INT_MAX - 10; i <= INT_MAX; i++)
    if (i + 1 < 0)
    {
        report_overflow ();
        break;
    }
```
由于这 2 种溢出，编译器可能会使用不兼容的包装假设来优化掉或者转换这 2 个比较。

如果你的代码使用像 `(i * 2000) / 1000` 这样的表达式，并且你实际想要乘法包装溢出，使用无符号运算来做，如 `((int) (i * 2000u)) / 1000`。

如果你的代码假设包装行为，并且你想将其与任何不支持该行为的 GCC 优化隔离，你应该使用 GCC 的 `-fwrapv` 选项，这会可靠地包装有符号溢出（不包括除法和取余，下节讨论）。

如果你需要介入有符号整型包装不可靠的平台（例如，由于硬件溢出检查，或者高度侵入优化），你应该考虑使用 GCC 的 `-ftrapv` 选项调试，它会在有符号溢出时抛出异常。


### A.5 有符号整数除法和取余溢出 { #Signed-Integer-Division }

有符号整数除法溢出并不总是无害的：例如，在 i386 家族的 CPU 上，用 `-1` 去除 `INT_MIN` 会产生 SIGFPE 信号，其默认行为是终止程序。更糟糕的是，这 2 个数取余通常产生同样的信号，尽管 C 标准要求 `INT_MIN % -1` 为 0 因为该表达式并没有溢出。
